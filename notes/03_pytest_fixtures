------------------------------------------------------------
| CHAPTER 3 - PYTEST FIXTURES                              |
------------------------------------------------------------

- Pytest Fixtures

    - Fixtures run before and after test functions.  

        import pytest
    
        @pytest.fixture()
        def some_data():
            return 42
    
        def test_some_data(some_data):
            assert some_data == 42

 
    - Pytest looks for the fixture name ('some_data' passed in as a parameter) in 
        the current module, and if it doesn't find it, will also try to look in 
        'conftest.py'.

      For our project, we'll put all of our fixtures in 'conftest.py' so that we 
        can share them across multiple test files.  Since conftest is implemented 
        as a pytest plugin, it does not need to be directly imported in our files.



- Using Fixtures for Setup and Teardown

    - Most of our tests assume that the Tasks database is already set up and 
        running.  We take care of this with the 'start_tasks_db' and 
        'stop_tasks_db' tasks.


    - The 'tmpdir' fixture gives us a temporary directory for testing that will
        automatically be cleaned up afterwards.


    - A fixture function runs before the tests that use it.  However, if there is
        a 'yield' in the function, it stops there, passes control to the tests,
        and picks up after all the tests are done.

      We'll add the fixture to set up and tear down the test db.

        # tasks_proj/tests/conftest.py
        --------------------------------------
        import pytest
        import tasks
        from tasks import Task

        @pytest.fixture()
        def tasks_db(tmpdir):
            tasks.start_tasks_db(str(tmpdir), 'tiny')
            yield
            tasks.stop_tasks_db()


    - Now, we'll change one of our tests to include the test db.

        # tasks_proj/tests/func/test_add.py
        ------------------------------------------------
        import pytest
        import tasks
        from tasks import Task

        def test_add_returns_valid_id(tasks_db):
            # GIVEN an initialized tasks db
            new_task = Task('do something')

            # WHEN a new task is added
            task_id = tasks.add(new_task)

            # THEN returned task_id is of type int
            assert isinstance(task_id, int)



- Tracing Execution with -setup-show

    - During development, it can be useful to output information about the
        fixtures that are run.  The '--setup-show' option is used for this.

        $ pytest --setup-show -v test_add.py



- Using Fixtures for Test Data

    - Fixtures are a good place to set up test data.  You can return anything.

        @pytest.fixture()
        def a_tuple():
            return (1, 'foo', None, {'bar': 23})

        def test_a_tuple(a_tuple):
            assert a_tuple[3]['bar'] == 23


    - Here are some tasks we will use as test data.

        # tasks_proj/tests/conftest.py
        ------------------------------------------
        # Reminder of Task constructor interface
        # Task(summary=None, owner=None, done=False, id=None)
        # summary is required
        # owner and done are optional
        # id is set by database

        @pytest.fixture()
        def tasks_just_a_few():
            return (
                Task('Write some code', 'Brian', True),
                Task('Code review Brian's code', 'Katie', False),
                Task('Fix what Brian did', 'Michelle', False))

        @pytest.fixture()
        def tasks_mult_per_owner():
            return (
                Task('Make a cookie', 'Raphael'),
                Task('Use an emoji', 'Raphael'),
                Task('Move to Berlin', 'Raphael'),

                Task('Create', 'Michelle'),
                Task('Inspire', 'Michelle'),
                Task('Encourage', 'Michelle'),

                Task('Do a handstand', 'Daniel'),
                Task('Write some books', 'Daniel'),
                Task('Eat ice cream', 'Daniel'))



- Using Multiple Fixtures

    - We can create fixtures that use other fixtures.

        # conftest.py
        ------------------------------------------
        @pytest.fixture()
        def db_with_3_tasks(tasks_db, tasks_just_a_few):
            """Connected db with 3 tasks, all unique."""
            for t in tasks_just_a_few:
                tasks.add(t)

        @pytest.fixture()
        def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner):
            """Connected db with 9 tasks, 3 owners, all with 3 tasks."""
            for t in tasks_mult_per_owner:
                tasks.add(t)


    - Then we can use the fixture:

        def test_add_increases_count(db_with_3_tasks):
            tasks.add(Task('throw a party'))
            assert tasks.count() == 4



- Specifying Fixture Scope

    - Fixtures can include the optional 'scope' parameter, which controls how often
        a fixture gets set up and torn down.

        scope='function'    # Runs once per test function (this is the default)
        scope='class'       # Runs once per test class
        scope='module'      # Runs once per module
        scope='session'     # Runs once per session


    - For example:

        @pytest.fixture(scope='function')
        def func_scope():
            """ Function scope fixture """

        @pytest.fixture(scope='module')
        def mod_scope():
            """ Module scope fixture """

        @pytest.fixture(scope='session')
        def sess_scope():
            """ Session scope fixture """

        @pytest.fixture(scope='class')
        def class_scope():
            """ Class scope fixture """


        def test1(sess_scope, mod_scope, func_scope):
            """ Use the session, module, and function scope fixtures. """


        @pytest.mark.usefixtures('class_scope')
        class TestSomething:

            def test2(self):
                """ Test using class scope fixture. """


    - Fixtures can only depend on other fixtures in their same scope or a wider scope.
        So, a function scope fixture can also depend on class, module, or session scope
        fixtures.  But you can't go in reverse order.



- Changing Scope for Tasks Project Fixtures

    - So far, we've been setting up a temporary directory and new connection to
        a database for each test.  Instead, we'll make the 'tasks_db' have a 
        session scope.

      In order to do this, we'll need to use 'tmpdir_factory' instead of 'tmpdir',
        since 'tmpdir' is a function scope and 'tmpdir_factory' is a session scope.


        # conftest.py
        ------------------------------------------
        @pytest.fixture(scope='session')
        def tasks_db_session(tmpdir_factory):
            """ Connect to db before tests, disconnect after """
            temp_dir = tmpdir_factory.mktemp('temp')
            tasks.start_tasks_db(str(temp_dir), 'tiny')
            yield
            tasks.stop_tasks_db()
  
        @pytest.fixture
        def tasks_db(tasks_db_session):
            """ An empty tasks db """
            tasks.delete_all()


    - Also, we'll make the tasks fixtures session-scope, since they are static and there
        is no reason to instantiate them multiple times.

        @pytest.fixture(scope='session')
        def tasks_just_a_few(): ...

        @pytest.fixture(scope='session')
        def tasks_mult_per_owner(): ...



- Specifying Fixtures with 'usefixtures'


- Using 'autouse' for Fixtures That Always Get Used


- Renaming Fixtures


- Parameterizing Fixtures