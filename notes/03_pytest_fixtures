------------------------------------------------------------
| CHAPTER 3 - PYTEST FIXTURES                              |
------------------------------------------------------------

- Pytest Fixtures

    - Fixtures run before and after test functions.  

        import pytest
    
        @pytest.fixture()
        def some_data():
            return 42
    
        def test_some_data(some_data):
            assert some_data == 42

 
    - Pytest looks for the fixture name ('some_data' passed in as a parameter) in 
        the current module, and if it doesn't find it, will also try to look in 
        'conftest.py'.

      For our project, we'll put all of our fixtures in 'conftest.py' so that we 
        can share them across multiple test files.  Since conftest is implemented 
        as a pytest plugin, it does not need to be directly imported in our files.



- Using Fixtures for Setup and Teardown

    - Most of our tests assume that the Tasks database is already set up and 
        running.  We take care of this with the 'start_tasks_db' and 
        'stop_tasks_db' tasks.


    - The 'tmpdir' fixture gives us a temporary directory for testing that will
        automatically be cleaned up afterwards.


    - A fixture function runs before the tests that use it.  However, if there is
        a 'yield' in the function, it stops there, passes control to the tests,
        and picks up after all the tests are done.

      We'll add the fixture to set up and tear down the test db.

        # tasks_proj/tests/conftest.py
        --------------------------------------
        import pytest
        import tasks
        from tasks import Task

        @pytest.fixture()
        def tasks_db(tmpdir):
            tasks.start_tasks_db(str(tmpdir), 'tiny')
            yield
            tasks.stop_tasks_db()


    - Now, we'll change one of our tests to include the test db.

        # tasks_proj/tests/func/test_add.py
        ------------------------------------------------
        import pytest
        import tasks
        from tasks import Task

        def test_add_returns_valid_id(tasks_db):
            # GIVEN an initialized tasks db
            new_task = Task('do something')

            # WHEN a new task is added
            task_id = tasks.add(new_task)

            # THEN returned task_id is of type int
            assert isinstance(task_id, int)



- Tracing Execution with -setup-show

    - During development, it can be useful to output information about the
        fixtures that are run.  The '--setup-show' option is used for this.

        $ pytest --setup-show -v test_add.py



- Using Fixtures for Test Data

    - Fixtures are a good place to set up test data.  You can return anything.

        @pytest.fixture()
        def a_tuple():
            return (1, 'foo', None, {'bar': 23})

        def test_a_tuple(a_tuple):
            assert a_tuple[3]['bar'] == 23


    - Here are some tasks we will use as test data.

        # tasks_proj/tests/conftest.py
        ------------------------------------------
        # Reminder of Task constructor interface
        # Task(summary=None, owner=None, done=False, id=None)
        # summary is required
        # owner and done are optional
        # id is set by database

        @pytest.fixture()
        def tasks_just_a_few():
            return (
                Task('Write some code', 'Brian', True),
                Task('Code review Brian's code', 'Katie', False),
                Task('Fix what Brian did', 'Michelle', False))

        @pytest.fixture()
        def tasks_mult_per_owner():
            return (
                Task('Make a cookie', 'Raphael'),
                Task('Use an emoji', 'Raphael'),
                Task('Move to Berlin', 'Raphael'),

                Task('Create', 'Michelle'),
                Task('Inspire', 'Michelle'),
                Task('Encourage', 'Michelle'),

                Task('Do a handstand', 'Daniel'),
                Task('Write some books', 'Daniel'),
                Task('Eat ice cream', 'Daniel'))



- Using Multiple Fixtures

    - 





- Specifying Fixture Scope


- Specifying Fixtures with 'usefixtures'


- Using 'autouse' for Fixtures That Always Get Used


- Renaming Fixtures


- Parameterizing Fixtures