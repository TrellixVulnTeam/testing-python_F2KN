------------------------------------------------------------
| CHAPTER 4 - BUILTIN FIXTURES                             |
------------------------------------------------------------

- Using 'tmpdir' and 'tmpdir_factory'

    - The 'tmpdir' and 'tmpdir_factory' fixtures are used to create a temporary
        file system directory before tests run, then remove the directory after 
        they are finished.  For instance, we can store temporary database files used
        by TinyDB and MongoDB in the directory.


    - The 'tmpdir' fixture has function scope, so it is used for individual tests.  The
        'tmpdir_factory' has session scope, so it is used for multiple tests.


    - Here is an example of using 'tmpdir':

        def test_tmpdir(tmpdir):
            # Create a filename (file won't be created until it's written to)
            a_file = tmpdir.join('something.txt')

            # Create a subdirectory
            subdir = tmpdir.mkdir('anything')

            # Create a filename in the subdirectory
            another_file = subdir.join('something-else.txt')

            # The files will actually be created when they're written to
            a_file.write('contents of file')
            another_file.write('contents of this file')

            # Read the files
            assert a_file.read() == 'contents of file'
            assert another_file.read() == 'contents of this file'


    - Here is an example of 'tmpdir_factory':

        def test_tmpdir_factory(tmpdir_factory):
            # Create a temp directory
            a_dir = tmpdir_factory.mktemp('mydir')

            # Can get the parent directory if you need it
            base_temp = tmpdir_factory.getbasetemp()

            # Use the temp directory and files exactly like with tmpdir example



- Using Temporary Directories for Other Scopes

    - Here, we create use the 'tmpdir_factory' for adding a file for module scope tests.

        import json, pytest

        @pytest.fixture(scope='module')
        def author_file_json(tmpdir_factory):
            python_author_data = {
                'Ned': {'City': 'Boston'},
                'Brian': {'City': 'Portland'},
                'Luciano': {'City': 'Sao Paolo'}
            }

            file = tmpdir_factory.mktemp('data').join('author_file.json')
            with file.open('w') as f:
                json.dump(python_author_data, f)

            return file


        def test_brian_in_portland(author_file_json):
            with author_file_json.open() as f:
                authors = json.load(f)
            assert authors['Brian']['City'] == 'Portland'



- Using 'pytestconfig'

    - The 'pytestconfig' builtin fixture allows you to control how pytest runs 
        through command-line arguments and options, config files, plugins, and the
        directory tests are run from.


    - Here, we'll create a few custom command-line options.

        # conftest.py
        -------------------------------
        def pytest_addoption(parser):
            parser.addoption('--myopt', action='store_true', help='some boolean option')
            parser.addoption('--foo', action='store', default='bar, help='foo: bar or baz')


        # See the custom options
        $ pytest --help


        # test_config.py
        -------------------------------
        # Access the options from within a test
        def test_option(pytestconfig):
            print('"foo" set to', pytestconfig.getoption('foo'))
            print('"myopt' set to', pytestconfig.getoption('myopt'))


        # Now see it in action
        $ pytest -s -q test_config.py::test_option
        $ pytest -s -q --myopt test_config.py::test_option
        $ pytest -s -q --foo bar test_config.py::test_option


    - There are also builtin options you can access with information about the pytest session.

        def test_pytestconfig(pytestconfig):
            print('args :', pytestconfig.args)
            print('inifile :', pytestconfig.inifile)
            print('invocation_dir :', pytestconfig.invocation_dir)
            print('rootdir :', pytestconfig.rootdir)
            print('-k EXPRESSION :', pytestconfig.getoption('keyword'))
            print('-v, --verbose :', pytestconfig.getoption('verbose'))
            print('-q, --quiet :', pytestconfig.getoption('quiet'))
            print('-l, --showlocals:', pytestconfig.getoption('showlocals'))
            print('--tb=style :', pytestconfig.getoption('tbstyle'))



- Using 'cache'

    - Usually, we want each test run to be independent, but sometimes, we want to
        pass information about one test session to the next one.  The 'cache' builtin
        fixture is used for that.


    - Here are builtin features that use the cache.

        # Rerun the tests that failed on the last run
        $ pytest -lf

        # Run all tests, starting with the ones that failed on last run
        $ pytest -ff


    - To see the information being stored in the cache

        # Show cache
        $ pytest --cache-show

        # Or can look in the cache directory
        $ cat.cache/v/cache/lastfailed


    - The interface for using the cache is simple:

        cache.get(key, default)
        cache.set(key, value)


    - Here is an example:

        @pytest.fixture(autouse=True)
        def check_duration(request, cache):
            start_time = datetime.datetime.now()
            yield
            end_time = datetime.datetime.now()
            duration = end_time - start_time
            cache.set('duration', duration)



- Using 'capsys'

    - The 'capsys' builtin fixture allows you to retrieve stdout and stderr from
        some code, and it disables output capture temporarily.


    - Suppose you have a function that prints to stdout.  We can test this.

        def greeting(name):
            print('Hi, {}'.format(name))

        def test_greeting(capsys):
            greeting('Earthling')
            out, err = capsys.readouterr()
            assert out == 'Hi, Earthling\n'
            assert err == ''


    - We can also test a function that prints to stderr.

        def yikes(problem):
            print('Yikes, {}'.format(problem), file=sys.stderr)

        def test_yikes(capsys):
            yikes('Out of coffee')
            out, err = capsys.readouterr()
            assert out == ''
            assert 'Out of coffee' in err



- Using 'monkeypatch'


- Using 'doctest_namespace'


- Using 'recwarn'